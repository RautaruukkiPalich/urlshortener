package apiserver

import (
	"context"
	"log/slog"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/rautaruukkipalich/urlsh/config"
	"github.com/rautaruukkipalich/urlsh/internal/cache"
	"github.com/rautaruukkipalich/urlsh/internal/store"
	logger "github.com/rautaruukkipalich/urlsh/pkg/log"

	_ "github.com/rautaruukkipalich/urlsh/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/swaggo/http-swagger/v2"
)

type db struct {
	stop store.StoreStopper
	get  store.StoreGetter
	set  store.StoreSetter
}

type cacher struct {
	stop cache.CacheStopper
	get  cache.CacheGetter
	set  cache.CacheSetter
}

type APIServer struct {
	store   *db
	cache   *cacher
	srv     *http.Server
	router  *mux.Router
	addr    string
	timeout time.Duration
}

func New(
	ctx context.Context,
	cfg *config.SRVConfig,
	storestop store.StoreStopper,
	storeget store.StoreGetter,
	storeset store.StoreSetter,
	cachestop cache.CacheStopper,
	cacheget cache.CacheGetter,
	cacheset cache.CacheSetter,
) *APIServer {
	// const op = "internal.apiserver.New"
	// ctx = logger.AddTrace(ctx, slog.Any("op", op))

	store := &db{
		stop: storestop,
		get:  storeget,
		set:  storeset,
	}

	cache := &cacher{
		stop: cachestop,
		get:  cacheget,
		set:  cacheset,
	}

	router := mux.NewRouter()

	return &APIServer{
		store:   store,
		cache:   cache,
		router:  router,
		addr:    cfg.Addr,
		timeout: cfg.Timeout,
	}
}

func (a *APIServer) MustRun(ctx context.Context) {
	if err := a.Run(ctx); err != nil {
		panic(err)
	}
}

func (a *APIServer) Run(ctx context.Context) error {
	const op = "internal.apiserver.Run"
	logger.AddTrace(ctx, slog.Any("op", op))

	a.configureRouter()

	a.srv = &http.Server{
		Addr:         a.addr,
		Handler:      a.router,
		ReadTimeout:  a.timeout,
		WriteTimeout: a.timeout,
	}

	logger.LoggerFromContext(ctx).Info("server started", slog.String("addr", a.srv.Addr))

	if err := a.srv.ListenAndServe(); err != nil {
		logger.LoggerFromContext(ctx).Warn("error while listen and serve", slog.Any("error", err.Error()))
		return err
	}
	return nil
}

// func (a *APIServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
// 	// fmt.Println(r.URL.Path, r.URL.Query, r.Method, r.Body)
// 	a.router.ServeHTTP(w, r)
// }

func (a *APIServer) configureRouter() {
	a.router = mux.NewRouter()

	// a.router.Handle("/metrics", promhttp.Handler())
	
	a.router.PathPrefix("/swagger/").HandlerFunc(httpSwagger.WrapHandler)

	a.router.Handle("/shorten", a.PushURLHandler()).Methods(http.MethodPost)
	a.router.Handle("/t/{any}", a.RedirectHandler()).Methods(http.MethodGet)
	a.router.Handle("/{any}", a.GetShortURLHandler()).Methods(http.MethodGet)
	// router.Handle("/{any}", a.RedirectShortUrl()).Methods("GET")
}

func (a *APIServer) Stop(ctx context.Context) error {
	const op = "internal.apiserver.Stop"
	ctx = logger.AddTrace(ctx, slog.Any("op", op))
	defer a.store.stop.Stop(ctx)
	defer a.cache.stop.Stop(ctx)

	logger.LoggerFromContext(ctx).Info("stop apiserver", slog.String("addr", a.srv.Addr))

	return nil
}
